<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XR_EdSpace - Living Textbook AR</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
        }
        
        #loading-screen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            max-width: 90%;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            backdrop-filter: blur(10px);
        }
        
        #info-panel.visible {
            opacity: 1;
        }
        
        #controls-hint {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        #controls-hint div {
            margin: 5px 0;
        }
        
        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 80%;
            text-align: center;
            z-index: 10001;
            display: none;
        }
        
        #error-message.visible {
            display: block;
        }
        
        #rotation-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        #rotation-feedback.visible {
            opacity: 1;
        }

        /* More Info button in bottom info panel */
        #more-info-btn {
            display: inline-block;
            margin-top: 10px;
            background: #ff5a5f;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        #more-info-btn:active {
            transform: translateY(1px);
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>XR_EdSpace</h1>
        <div class="spinner"></div>
        <p style="margin-top: 20px;">Initializing AR...</p>
    </div>
    
    <div id="controls-hint">
        <div>üëÜ Drag to rotate</div>
        <div>ü§è Pinch to zoom</div>
        <div>‚úåÔ∏è Two fingers to pan</div>
        <div>‚è∏Ô∏è Long press to pause</div>
    </div>
    
    <div id="info-panel">
        <div id="info-text">Point camera at marker</div>
        <!-- More Info button will be added/removed dynamically -->
    </div>
    
    <div id="error-message">
        <h2>‚ö†Ô∏è AR Error</h2>
        <p>Unable to access camera. Please ensure:</p>
        <ul style="text-align: left; display: inline-block;">
            <li>Camera permissions are granted</li>
            <li>You're using HTTPS</li>
            <li>Your browser supports WebXR</li>
        </ul>
    </div>
    
    <div id="rotation-feedback"></div>
    
    <a-scene
        mindar-image="imageTargetSrc: ./assets/targets.mind; maxTrack: 2; filterMinCF: 0.0001; filterBeta: 0.01;"
        color-space="sRGB"
        renderer="colorManagement: true, physicallyCorrectLights"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false">
        
        <a-assets>
            <a-asset-item id="heartModel" src="./models/Heart__photor.glb"></a-asset-item>
            <a-asset-item id="brainModel" src="./models/Brain_NIH3D.glb"></a-asset-item>
        </a-assets>
        
        <!-- Camera with mouse cursor for desktop clicks -->
        <a-camera position="0 0 0" look-controls="enabled: false">
            <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
        </a-camera>
        
        <!-- Heart Target -->
        <a-entity mindar-image-target="targetIndex: 0">
            <a-gltf-model
                id="heart-model"
                src="#heartModel"
                position="0 0 0"
                scale="0.5 0.5 0.5"
                rotation="0 0 0"
                animation="property: rotation; to: 0 360 0; loop: true; dur: 10000; easing: linear">
            </a-gltf-model>

            <!-- (Kept but hidden) Info button for the heart in-scene (was on top) -->
            <a-entity id="heart-info-button"
                      class="clickable"
                      visible="false"
                      geometry="primitive: plane; width: 0.6; height: 0.18"
                      material="color: #ff5a5f; shader: flat; opacity: 0.95"
                      position="0 0.25 0.35"
                      rotation="-25 0 0">
                <a-text value="More Info" color="#ffffff" align="center" position="0 0 0.01" width="1.2" />
            </a-entity>
        </a-entity>
        
        <!-- Brain Target -->
        <a-entity mindar-image-target="targetIndex: 1">
            <a-gltf-model
                id="brain-model"
                src="#brainModel"
                position="0 0 0"
                scale="0.003 0.003 0.003"
                rotation="0 0 0"
                animation="property: rotation; to: 0 360 0; loop: true; dur: 10000; easing: linear">
            </a-gltf-model>
        </a-entity>
    </a-scene>
    
    <script>
        // Model information (capitalized titles)
        const modelInfo = {
            heart: {
                title: "Basic Heart",
                facts: ""
            },
            brain: {
                title: "Basic Brain",
                facts: ""
            }
        };
        
        // External link for heart info
        const heartInfoUrl = 'https://my.clevelandclinic.org/health/body/21704-heart';
        
        // Get elements
        const sceneEl = document.querySelector('a-scene');
        const loadingScreen = document.getElementById('loading-screen');
        const infoPanel = document.getElementById('info-panel');
        const infoText = document.getElementById('info-text');
        const errorMessage = document.getElementById('error-message');
        const rotationFeedback = document.getElementById('rotation-feedback');
        
        let currentTarget = null;
        let isRotationPaused = false;
        const LONG_PRESS_DURATION = 500; // milliseconds

        // Hide loading screen when AR is ready
        sceneEl.addEventListener('arReady', () => {
            console.log('AR Ready');
            loadingScreen.style.display = 'none';
            infoPanel.classList.add('visible');
        });
        
        // Handle AR errors
        sceneEl.addEventListener('arError', (event) => {
            console.error('AR Error:', event.detail);
            loadingScreen.style.display = 'none';
            errorMessage.classList.add('visible');
        });
        
        // Target found - show model info
        sceneEl.addEventListener('targetFound', (event) => {
            // Determine targetIndex robustly
            let targetIndex = null;
            try {
                const attr = event.target.getAttribute && event.target.getAttribute('mindar-image-target');
                if (typeof attr === 'string') {
                    const match = attr.match(/targetIndex:\s*(\d+)/);
                    if (match) targetIndex = match[1];
                    else targetIndex = attr;
                } else if (attr && typeof attr === 'object' && attr.targetIndex !== undefined) {
                    targetIndex = String(attr.targetIndex);
                } else if (event.detail && event.detail.targetIndex !== undefined) {
                    targetIndex = String(event.detail.targetIndex);
                } else if (event.target.components && event.target.components['mindar-image-target'] && event.target.components['mindar-image-target'].data) {
                    targetIndex = String(event.target.components['mindar-image-target'].data.targetIndex);
                }
            } catch (e) {
                console.warn('Could not read mindar-image-target attribute directly:', e);
            }

            if (targetIndex === null) {
                console.warn('targetFound fired but targetIndex could not be determined.', event);
                return;
            }

            if (targetIndex === '0') {
                currentTarget = 'heart';
                const heartText = modelInfo.heart.facts ? 
                    `<strong>${modelInfo.heart.title}</strong><br>${modelInfo.heart.facts}` : 
                    `<strong>${modelInfo.heart.title}</strong>`;
                infoText.innerHTML = heartText;
                showMoreInfoButton(true);
            } else if (targetIndex === '1') {
                currentTarget = 'brain';
                const brainText = modelInfo.brain.facts ? 
                    `<strong>${modelInfo.brain.title}</strong><br>${modelInfo.brain.facts}` : 
                    `<strong>${modelInfo.brain.title}</strong>`;
                infoText.innerHTML = brainText;
                showMoreInfoButton(false);
            } else {
                currentTarget = null;
                infoText.innerHTML = 'Unknown target';
                showMoreInfoButton(false);
            }
            
            infoPanel.classList.add('visible');
        });
        
        // Target lost - hide info
        sceneEl.addEventListener('targetLost', () => {
            currentTarget = null;
            infoPanel.classList.remove('visible');
            showMoreInfoButton(false);
        });

        // Create or show/hide More Info button inside the bottom info panel
        function showMoreInfoButton(show) {
            let btn = document.getElementById('more-info-btn');
            if (show) {
                if (!btn) {
                    btn = document.createElement('button');
                    btn.id = 'more-info-btn';
                    btn.textContent = 'More Info';
                    btn.addEventListener('click', openHeartInfo);
                    btn.addEventListener('touchend', function(e) {
                        // prevent other handlers and open link
                        e.preventDefault();
                        e.stopPropagation();
                        openHeartInfo(e);
                    }, {passive:false});
                    infoPanel.appendChild(btn);
                } else {
                    btn.style.display = 'inline-block';
                }
            } else {
                if (btn) btn.style.display = 'none';
            }
        }

        function openHeartInfo(evt) {
            // If no heart is currently in view, do nothing
            if (currentTarget !== 'heart') return;
            // Open in a new tab/window
            window.open(heartInfoUrl, '_blank', 'noopener,noreferrer');
        }

        // Gesture controls (kept for rotation/scale/pan)
        AFRAME.registerComponent('gesture-handler', {
            schema: {
                enabled: { default: true },
                rotationFactor: { default: 5 },
                minScale: { default: 0.3 },
                maxScale: { default: 8 }
            },
            
            init: function () {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                this.handlePan = this.handlePan.bind(this);
                
                this.isVisible = false;
                this.initialScale = this.el.object3D.scale.clone();
                this.scaleFactor = 1;
                
                // listen for targetFound/targetLost and check parentNode
                this.el.sceneEl.addEventListener('targetFound', (e) => {
                    if (e.target === this.el.parentNode) {
                        this.isVisible = true;
                    }
                });
                
                this.el.sceneEl.addEventListener('targetLost', (e) => {
                    if (e.target === this.el.parentNode) {
                        this.isVisible = false;
                    }
                });
                
                // Touch event listeners on the scene (so touches anywhere will be received)
                this.el.sceneEl.addEventListener('touchstart', this.startGesture.bind(this));
                this.el.sceneEl.addEventListener('touchmove', this.moveGesture.bind(this));
                this.el.sceneEl.addEventListener('touchend', this.endGesture.bind(this));
            },
            
            startGesture: function (event) {
                if (!this.isVisible) return;
                
                this.initialTouches = Array.from(event.touches);
                
                // Start long press timer (component-level long-press)
                if (event.touches.length === 1) {
                    // store timer id to global longpress (so it can be cancelled elsewhere too)
                    window._componentLongPressTimer = setTimeout(() => {
                        toggleRotation();
                    }, LONG_PRESS_DURATION);
                }
            },
            
            moveGesture: function (event) {
                if (!this.isVisible || !this.initialTouches) return;
                
                // Cancel long press if finger moves
                if (window._componentLongPressTimer) {
                    clearTimeout(window._componentLongPressTimer);
                    window._componentLongPressTimer = null;
                }
                
                if (event.touches.length === 2 && this.initialTouches.length === 2) {
                    // Two finger gestures
                    this.handleScale(event);
                    this.handlePan(event);
                } else if (event.touches.length === 1 && this.initialTouches.length === 1) {
                    // One finger rotation
                    this.handleRotation(event);
                }
                
                this.initialTouches = Array.from(event.touches);
            },
            
            endGesture: function () {
                // Cancel long press timer
                if (window._componentLongPressTimer) {
                    clearTimeout(window._componentLongPressTimer);
                    window._componentLongPressTimer = null;
                }
                
                this.initialTouches = null;
            },
            
            handleRotation: function (event) {
                if (!this.initialTouches || this.initialTouches.length !== 1) return;
                
                const touch = event.touches[0];
                const initialTouch = this.initialTouches[0];
                
                const deltaX = touch.pageX - initialTouch.pageX;
                const deltaY = touch.pageY - initialTouch.pageY;
                
                const rotation = this.el.object3D.rotation;
                rotation.y += deltaX / 100 * this.data.rotationFactor;
                rotation.x += deltaY / 100 * this.data.rotationFactor;
            },
            
            handleScale: function (event) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                const initialTouch1 = this.initialTouches[0];
                const initialTouch2 = this.initialTouches[1];
                
                const initialDistance = Math.hypot(
                    initialTouch1.pageX - initialTouch2.pageX,
                    initialTouch1.pageY - initialTouch2.pageY
                );
                
                const currentDistance = Math.hypot(
                    touch1.pageX - touch2.pageX,
                    touch1.pageY - touch2.pageY
                );
                
                const scaleChange = currentDistance / initialDistance;
                this.scaleFactor *= scaleChange;
                this.scaleFactor = Math.max(this.data.minScale, Math.min(this.data.maxScale, this.scaleFactor));
                
                const newScale = this.initialScale.clone().multiplyScalar(this.scaleFactor);
                this.el.object3D.scale.copy(newScale);
            },
            
            handlePan: function (event) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                const initialTouch1 = this.initialTouches[0];
                const initialTouch2 = this.initialTouches[1];
                
                const midX = (touch1.pageX + touch2.pageX) / 2;
                const midY = (touch1.pageY + touch2.pageY) / 2;
                
                const initialMidX = (initialTouch1.pageX + initialTouch2.pageX) / 2;
                const initialMidY = (initialTouch1.pageY + initialTouch2.pageY) / 2;
                
                const deltaX = (midX - initialMidX) / 1000;
                const deltaY = (midY - initialMidY) / 1000;
                
                const position = this.el.object3D.position;
                position.x += deltaX;
                position.y -= deltaY;
            }
        });
        
        function showRotationFeedback(message) {
            rotationFeedback.textContent = message;
            rotationFeedback.classList.add('visible');
            
            setTimeout(() => {
                rotationFeedback.classList.remove('visible');
            }, 1500);
        }
        
        // Centralized toggleRotation with robust pause/play handling
        function toggleRotation() {
            isRotationPaused = !isRotationPaused;
            const heartModel = document.getElementById('heart-model');
            const brainModel = document.getElementById('brain-model');
            [heartModel, brainModel].forEach(m => {
                if (!m) return;
                // If the animation component is available and exposes pause/play, use it
                if (m.components && m.components.animation && typeof m.components.animation.pause === 'function') {
                    try {
                        if (isRotationPaused) {
                            m.components.animation.pause();
                        } else {
                            m.components.animation.play();
                        }
                    } catch (e) {
                        // fallback to attribute-based enable/disable
                        m.setAttribute('animation', 'enabled: ' + (!isRotationPaused));
                    }
                } else {
                    // Fallback: set the animation enabled property (A-Frame will parse this)
                    m.setAttribute('animation', 'enabled: ' + (!isRotationPaused));
                }
            });
            showRotationFeedback(isRotationPaused ? '‚è∏Ô∏è Rotation Paused' : '‚ñ∂Ô∏è Rotation Resumed');
        }

        // Add gesture handler to models and hook up the heart info button (bottom DOM button used)
        document.addEventListener('DOMContentLoaded', () => {
            const heartModel = document.getElementById('heart-model');
            const brainModel = document.getElementById('brain-model');
            const heartInfoButton = document.getElementById('heart-info-button');
            
            if (heartModel) heartModel.setAttribute('gesture-handler', '');
            if (brainModel) brainModel.setAttribute('gesture-handler', '');
            if (heartInfoButton) {
                // Hide the in-scene button (we use the bottom info-panel button instead)
                heartInfoButton.setAttribute('visible', 'false');
            }
        });

        // Global/document-level long-press handling (ensures long-press works regardless of component wiring)
        (function setupGlobalLongPress() {
            let globalLongPressTimer = null;

            function startGlobalLongPress(e) {
                // Only consider single-finger long press
                if (currentTarget && ((e.touches && e.touches.length === 1) || e.pointerType === 'touch' || e.pointerType === undefined)) {
                    // avoid starting if already started
                    if (globalLongPressTimer) return;
                    globalLongPressTimer = setTimeout(() => {
                        toggleRotation();
                        globalLongPressTimer = null;
                    }, LONG_PRESS_DURATION);
                }
            }
            function cancelGlobalLongPress() {
                if (globalLongPressTimer) {
                    clearTimeout(globalLongPressTimer);
                    globalLongPressTimer = null;
                }
            }

            document.addEventListener('touchstart', startGlobalLongPress, {passive: true});
            document.addEventListener('touchmove', cancelGlobalLongPress, {passive: true});
            document.addEventListener('touchend', cancelGlobalLongPress, {passive: true});
            document.addEventListener('touchcancel', cancelGlobalLongPress, {passive: true});

            // Pointer events fallback for some browsers/devices
            document.addEventListener('pointerdown', (e) => {
                if (e.pointerType === 'touch') startGlobalLongPress(e);
            });
            document.addEventListener('pointermove', cancelGlobalLongPress);
            document.addEventListener('pointerup', cancelGlobalLongPress);
            document.addEventListener('pointercancel', cancelGlobalLongPress);
        })();
    </script>
</body>
</html>
