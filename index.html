<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XR_EdSpace - Living Textbook AR</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
        }
        
        #loading-screen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            max-width: 80%;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            backdrop-filter: blur(10px);
        }
        
        #info-panel.visible {
            opacity: 1;
        }
        
        #controls-hint {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        #controls-hint div {
            margin: 5px 0;
        }
        
        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 80%;
            text-align: center;
            z-index: 10001;
            display: none;
        }
        
        #error-message.visible {
            display: block;
        }
        
        #rotation-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        #rotation-feedback.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>XR_EdSpace</h1>
        <div class="spinner"></div>
        <p style="margin-top: 20px;">Initializing AR...</p>
    </div>
    
    <div id="controls-hint">
        <div>üëÜ Drag to rotate</div>
        <div>ü§è Pinch to zoom</div>
        <div>‚úåÔ∏è Two fingers to pan</div>
        <div>‚è∏Ô∏è Long press to pause</div>
    </div>
    
    <div id="info-panel">
        <div id="info-text">Point camera at marker</div>
    </div>
    
    <div id="error-message">
        <h2>‚ö†Ô∏è AR Error</h2>
        <p>Unable to access camera. Please ensure:</p>
        <ul style="text-align: left; display: inline-block;">
            <li>Camera permissions are granted</li>
            <li>You're using HTTPS</li>
            <li>Your browser supports WebXR</li>
        </ul>
    </div>
    
    <div id="rotation-feedback"></div>
    
    <a-scene
        mindar-image="imageTargetSrc: ./assets/targets.mind; maxTrack: 2; filterMinCF: 0.0001; filterBeta: 0.01;"
        color-space="sRGB"
        renderer="colorManagement: true, physicallyCorrectLights"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false">
        
        <a-assets>
            <a-asset-item id="heartModel" src="./models/Heart__photor.glb"></a-asset-item>
            <a-asset-item id="brainModel" src="./models/Brain_NIH3D.glb"></a-asset-item>
        </a-assets>
        
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        
        <!-- Heart Target -->
        <a-entity mindar-image-target="targetIndex: 0">
            <a-gltf-model
                id="heart-model"
                src="#heartModel"
                position="0 0 0"
                scale="0.5 0.5 0.5"
                rotation="0 0 0"
                animation="property: rotation; to: 0 360 0; loop: true; dur: 10000; easing: linear">
            </a-gltf-model>
        </a-entity>
        
        <!-- Brain Target -->
        <a-entity mindar-image-target="targetIndex: 1">
            <a-gltf-model
                id="brain-model"
                src="#brainModel"
                position="0 0 0"
                scale="0.003 0.003 0.003"
                rotation="0 0 0"
                animation="property: rotation; to: 0 360 0; loop: true; dur: 10000; easing: linear">
            </a-gltf-model>
        </a-entity>
    </a-scene>
    
    <script>
        // Model information (capitalized titles)
        const modelInfo = {
            heart: {
                title: "Basic Heart",
                facts: ""
            },
            brain: {
                title: "Basic Brain",
                facts: ""
            }
        };
        
        // Get elements
        const sceneEl = document.querySelector('a-scene');
        const loadingScreen = document.getElementById('loading-screen');
        const infoPanel = document.getElementById('info-panel');
        const infoText = document.getElementById('info-text');
        const errorMessage = document.getElementById('error-message');
        const rotationFeedback = document.getElementById('rotation-feedback');
        
        let currentTarget = null;
        let isRotationPaused = false;
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 500; // milliseconds
        
        // Hide loading screen when AR is ready
        sceneEl.addEventListener('arReady', () => {
            console.log('AR Ready');
            loadingScreen.style.display = 'none';
            infoPanel.classList.add('visible');
        });
        
        // Handle AR errors
        sceneEl.addEventListener('arError', (event) => {
            console.error('AR Error:', event.detail);
            loadingScreen.style.display = 'none';
            errorMessage.classList.add('visible');
        });
        
        // Target found - show model info
        sceneEl.addEventListener('targetFound', (event) => {
            // The mindar-image-target attribute can be returned as a string or object depending on A-Frame version.
            // Be robust and check several places for the targetIndex.
            let targetIndex = null;
            try {
                const attr = event.target.getAttribute('mindar-image-target');
                if (typeof attr === 'string') {
                    const match = attr.match(/targetIndex:\s*(\d+)/);
                    if (match) targetIndex = match[1];
                    else targetIndex = attr;
                } else if (attr && typeof attr === 'object' && attr.targetIndex !== undefined) {
                    targetIndex = String(attr.targetIndex);
                } else if (event.detail && event.detail.targetIndex !== undefined) {
                    targetIndex = String(event.detail.targetIndex);
                } else if (event.target.components && event.target.components['mindar-image-target'] && event.target.components['mindar-image-target'].data) {
                    targetIndex = String(event.target.components['mindar-image-target'].data.targetIndex);
                }
            } catch (e) {
                console.warn('Could not read mindar-image-target attribute directly:', e);
            }

            // If still null, bail out
            if (targetIndex === null) {
                console.warn('targetFound fired but targetIndex could not be determined.', event);
                return;
            }

            if (targetIndex === '0') {
                currentTarget = 'heart';
                const heartText = modelInfo.heart.facts ? 
                    `<strong>${modelInfo.heart.title}</strong><br>${modelInfo.heart.facts}` : 
                    `<strong>${modelInfo.heart.title}</strong>`;
                infoText.innerHTML = heartText;
            } else if (targetIndex === '1') {
                currentTarget = 'brain';
                const brainText = modelInfo.brain.facts ? 
                    `<strong>${modelInfo.brain.title}</strong><br>${modelInfo.brain.facts}` : 
                    `<strong>${modelInfo.brain.title}</strong>`;
                infoText.innerHTML = brainText;
            } else {
                // other targets if added later
                currentTarget = null;
                infoText.innerHTML = 'Unknown target';
            }
            
            infoPanel.classList.add('visible');
        });
        
        // Target lost - hide info
        sceneEl.addEventListener('targetLost', () => {
            currentTarget = null;
            infoPanel.classList.remove('visible');
        });
        
        // Gesture controls
        AFRAME.registerComponent('gesture-handler', {
            schema: {
                enabled: { default: true },
                rotationFactor: { default: 5 },
                minScale: { default: 0.3 },
                maxScale: { default: 8 }
            },
            
            init: function () {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                this.handlePan = this.handlePan.bind(this);
                
                this.isVisible = false;
                this.initialScale = this.el.object3D.scale.clone();
                this.scaleFactor = 1;
                
                this.el.sceneEl.addEventListener('targetFound', (e) => {
                    if (e.target === this.el.parentNode) {
                        this.isVisible = true;
                    }
                });
                
                this.el.sceneEl.addEventListener('targetLost', (e) => {
                    if (e.target === this.el.parentNode) {
                        this.isVisible = false;
                    }
                });
                
                // Touch event listeners
                this.el.sceneEl.addEventListener('touchstart', this.startGesture.bind(this));
                this.el.sceneEl.addEventListener('touchmove', this.moveGesture.bind(this));
                this.el.sceneEl.addEventListener('touchend', this.endGesture.bind(this));
            },
            
            startGesture: function (event) {
                if (!this.isVisible) return;
                
                this.initialTouches = Array.from(event.touches);
                
                // Start long press timer
                if (event.touches.length === 1) {
                    longPressTimer = setTimeout(() => {
                        this.toggleRotation();
                    }, LONG_PRESS_DURATION);
                }
            },
            
            moveGesture: function (event) {
                if (!this.isVisible || !this.initialTouches) return;
                
                // Cancel long press if finger moves
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (event.touches.length === 2 && this.initialTouches.length === 2) {
                    // Two finger gestures
                    this.handleScale(event);
                    this.handlePan(event);
                } else if (event.touches.length === 1 && this.initialTouches.length === 1) {
                    // One finger rotation
                    this.handleRotation(event);
                }
                
                this.initialTouches = Array.from(event.touches);
            },
            
            endGesture: function () {
                // Cancel long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                this.initialTouches = null;
            },
            
            handleRotation: function (event) {
                if (this.initialTouches.length !== 1) return;
                
                const touch = event.touches[0];
                const initialTouch = this.initialTouches[0];
                
                const deltaX = touch.pageX - initialTouch.pageX;
                const deltaY = touch.pageY - initialTouch.pageY;
                
                const rotation = this.el.object3D.rotation;
                rotation.y += deltaX / 100 * this.data.rotationFactor;
                rotation.x += deltaY / 100 * this.data.rotationFactor;
            },
            
            handleScale: function (event) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                const initialTouch1 = this.initialTouches[0];
                const initialTouch2 = this.initialTouches[1];
                
                const initialDistance = Math.hypot(
                    initialTouch1.pageX - initialTouch2.pageX,
                    initialTouch1.pageY - initialTouch2.pageY
                );
                
                const currentDistance = Math.hypot(
                    touch1.pageX - touch2.pageX,
                    touch1.pageY - touch2.pageY
                );
                
                const scaleChange = currentDistance / initialDistance;
                this.scaleFactor *= scaleChange;
                this.scaleFactor = Math.max(this.data.minScale, Math.min(this.data.maxScale, this.scaleFactor));
                
                const newScale = this.initialScale.clone().multiplyScalar(this.scaleFactor);
                this.el.object3D.scale.copy(newScale);
            },
            
            handlePan: function (event) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                const initialTouch1 = this.initialTouches[0];
                const initialTouch2 = this.initialTouches[1];
                
                const midX = (touch1.pageX + touch2.pageX) / 2;
                const midY = (touch1.pageY + touch2.pageY) / 2;
                
                const initialMidX = (initialTouch1.pageX + initialTouch2.pageX) / 2;
                const initialMidY = (initialTouch1.pageY + initialTouch2.pageY) / 2;
                
                const deltaX = (midX - initialMidX) / 1000;
                const deltaY = (midY - initialMidY) / 1000;
                
                const position = this.el.object3D.position;
                position.x += deltaX;
                position.y -= deltaY;
            },
            
            toggleRotation: function () {
                isRotationPaused = !isRotationPaused;
                
                const heartModel = document.getElementById('heart-model');
                const brainModel = document.getElementById('brain-model');
                
                if (isRotationPaused) {
                    heartModel.setAttribute('animation', 'enabled', false);
                    brainModel.setAttribute('animation', 'enabled', false);
                    showRotationFeedback('‚è∏Ô∏è Rotation Paused');
                } else {
                    heartModel.setAttribute('animation', 'enabled', true);
                    brainModel.setAttribute('animation', 'enabled', true);
                    showRotationFeedback('‚ñ∂Ô∏è Rotation Resumed');
                }
            }
        });
        
        function showRotationFeedback(message) {
            rotationFeedback.textContent = message;
            rotationFeedback.classList.add('visible');
            
            setTimeout(() => {
                rotationFeedback.classList.remove('visible');
            }, 1500);
        }
        
        // Add gesture handler to models
        document.addEventListener('DOMContentLoaded', () => {
            const heartModel = document.getElementById('heart-model');
            const brainModel = document.getElementById('brain-model');
            
            if (heartModel) heartModel.setAttribute('gesture-handler', '');
            if (brainModel) brainModel.setAttribute('gesture-handler', '');
        });
    </script>
</body>
</html>
